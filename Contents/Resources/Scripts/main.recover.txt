property name : "HTMLElement"property XList : missing valueproperty XDict : missing valueproperty ShowHelpBook : missing valueon __load__(loader)	set ShowHelpBook to missing value	tell loader		set XList to load("XList")		set XDict to load("XDict")	end tell	return missing valueend __load__on _compile(loader)	__load__(loader)	set ShowHelpBook to loader's load("ShowHelpBook")	return missing valueend _compileproperty _ : _compile(proxy() of application (get "ModuleLoader"))property _line_end : ASCII character 10(*!@title HTMLElement ReferenceBuilding HTML with object oriented interface*)(*!@group Class Methods*)(*!@abstruct Get a character for line breaking@result text : The default value is line feed*)on line_end()	return my _line_endend line_end(*!@abstruct set a character for line break@result text*)on set_line_end(a_char)	set my _line_end to a_charend set_line_endon build_tag_info()	set a_dict to make XDict		-- inline type	set tags to {"span", "a", "b", "input", "i"}	set a_tag_info to {is_empty:false, before_start:"", after_start:"", before_end:"", after_end:""}	a_dict's set_value(tags, a_tag_info)		-- br type	set tags to {"br"}	set a_tag_info to {is_empty:true, before_start:"", after_start:_line_end, before_end:"", after_end:""}	a_dict's set_value(tags, a_tag_info)		-- online empty	set tags to {"img", "meta", "hr"}	set a_tag_info to {is_empty:true, before_start:_line_end, after_start:_line_end, before_end:"", after_end:""}	a_dict's set_value(tags, a_tag_info)		-- paragraph type	set tags to {"p", "h1", "h2", "h3", "h4", "h5", "h6", "li"}	set a_tag_info to {is_empty:false, before_start:_line_end, after_start:"", before_end:"", after_end:_line_end}	a_dict's set_value(tags, a_tag_info)		return a_dictend build_tag_infoproperty _tag_info_dict : build_tag_info()property _div_type_info : {is_empty:false, before_start:_line_end, after_start:_line_end, before_end:_line_end, after_end:_line_end}on tag_info_for(a_name)	set target_info to missing value		script TagInfoSearch		on do({tags, a_tag_info})			if a_name is in tags then				set target_info to a_tag_info				return false			end if			return true		end do	end script		_tag_info_dict's each(TagInfoSearch)		if target_info is missing value then		set target_info to _div_type_info	end if	return target_infoend tag_info_for(*!@abstruct encode character to html entities@param a_xtext (XText)@result XText*)on encode_to_entities(a_xtext)	set a_xtext to a_xtext's replace("&", "&amp;")	set a_xtext to a_xtext's replace(">", "&gt;")	set a_xtext to a_xtext's replace("<", "&lt;")	set a_xtext to a_xtext's replace(quote, "&quot;")	return a_xtextend encode_to_entities(*!@group Constructor *)(*!@abstruct make a new HTMLElement instance@param elem_name (string or Unicode text)@param att_list (list) : {{"att1", "value1"}, {"att2", "value2"}} @result script object : an HTMLElement instance*)on make_with(elem_name, att_list)	script HTMLElement		property _elem_name : elem_name		property _attributes : XDict's make_with_pairs(att_list)		property _contents : make XList		property _info : tag_info_for(elem_name)	end scriptend make_withon make	return make_with("", {})end make(*!@abstruct make a new HTMLElement instance for a comment tag@param a_text (string or Unicode text)@param att_list (list)@result script object : an HTMLElement instance for a comment tag*)on comment_with(a_text, att_list)	script CommentTag		property _contents : a_text		property _attributes : XDict's make_with_pairs(att_list)		property _info : _div_type_info				on as_unicode()			return as_html()		end as_unicode				on as_xhtml()			return as_html()		end as_xhtml				on as_html()			set out_list to XList's make_with({"<!--"})						if _contents is not in {"", missing value} then				out_list's push(_contents)			end if						set attrs to attr_text()			if attrs is not "" then				out_list's push(attrs)			end if			return out_list's as_unicode_with(space)		end as_html	end scriptend comment_with(*!@group Instance Methods *)on dump()	set a_result to my _elem_name & return & (my _attributes's dump())	set a_result to a_result & "contents : " & return & my _contents's dump()	return a_resultend dumpon set_attribute(a_name, a_value)	my _attributes's set_value(a_name, a_value)end set_attributeon element_name()	return my _elem_nameend element_nameon set_element_name(a_name)	set my _elem_name to a_name	return a_nameend set_element_nameon push(a_value)	my _contents's push(a_value)	return a_valueend pushon push_content(a_value)	return push(a_value)end push_contenton contents_ref()	return my _contentsend contents_refon push_element_with(elem_name, att_list)	set an_elem to make_with(elem_name, att_list)	push(an_elem)	return an_elemend push_element_withon push_comment_with(elem_name, att_list)	set an_elem to comment_with(elem_name, att_list)	push(an_elem)	return an_elemend push_comment_withon push_anchor_with(anchor_text)	set an_elem to make_with("a", {{"id", anchor_text}, {"name", anchor_text}})	push(an_elem)	return an_elemend push_anchor_withon attr_text()	set an_iterator to my _attributes's iterator()	set attr_list to make XList	repeat while an_iterator's has_next()		set att_pair to an_iterator's next()		repeat with a_val in att_pair			if class of a_val is script then				set contents of a_val to a_val's as_unicode()			end if		end repeat		attr_list's push(item 1 of att_pair & "=" & quote & item 2 of att_pair & quote)	end repeat	return attr_list's as_unicode_with(space)end attr_texton empty_tag()	set attrs to attr_text()	if attrs is not "" then		set attrs to space & attrs	end if	return "<" & my _elem_name & attrs & " />"end empty_tagon start_tag()	if my _elem_name is "" then		return ""	end if	set attrs to attr_text()	if attrs is not "" then		set attrs to space & attrs	end if	return "<" & my _elem_name & attrs & ">"end start_tagon end_tag()	if my _elem_name is "" then		return ""	end if		return "</" & my _elem_name & ">"end end_tagon as_unicode()	return as_html()end as_unicode(*!@abstruct output as XHTML text@result text*)on as_xhtml()	return as_html()end as_xhtmlon as_html()	local out_list	if my _info's is_empty then		return empty_tag() & (my _info's after_start)	end if		set out_list to make XList	set a_start_tag to start_tag()	if a_start_tag is not "" then		out_list's push(a_start_tag)		out_list's push(my _info's after_start)	end if		set pre_end to my _info's after_start	script TagContentsBuilder		property _out_list : out_list		property _pre_end : pre_end				on do(a_content)			set a_class to class of contents of a_content			if a_class is script then				if name of a_content is "HTMLElement" then					if _pre_end is not a_content's _info's before_start then						_out_list's push(a_content's _info's before_start)					end if				end if				_out_list's push(a_content's as_unicode())				if name of a_content is "HTMLElement" then					_out_list's push(a_content's _info's after_end)					set _pre_end to a_content's _info's after_end				end if			else				_out_list's push(a_content as Unicode text)				set _pre_end to ""			end if						return true		end do	end script		my _contents's each(TagContentsBuilder)	if (out_list's item_counts() < 1 or out_list's item_at(-1) does not end with my _info's before_end) then		out_list's push(my _info's before_end)	end if		if a_start_tag is "" then		if out_list's item_at(-1) is _line_end then			set_item of out_list for "" at -1		end if	else		out_list's push(end_tag())		--out_list's push(my _info's after_end)	end if	return out_list's as_unicode_with("")end as_htmlon debug()	(*	set a_tag to make_with("a", {{"href", "hello"}})	a_tag's push("yo")	log a_tag's as_html	*)	set par_container to make	log par_container's as_html()end debugon run	--return debug()	run ShowHelpBookend run